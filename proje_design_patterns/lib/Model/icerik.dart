class Icerik {
  String? baslik;
  String? icerik;
  int? kategori_id;
  Icerik({required this.kategori_id,required this.baslik,required this.icerik});

  Icerik.fromMap(Map<String, dynamic> veri) {
    baslik = veri["baslik"];
    icerik = veri["icerik"];
    kategori_id=veri["kategori_id"];
  }
  Map<String,dynamic> toMap(){
    return {
      "baslik":baslik,
      "icerik":icerik,
      "kategori_id":kategori_id,
    };
  }
   static List<Icerik> eklenenler = [
      Icerik(kategori_id:1,baslik: "Singleton Pattern", icerik: "En basit tasarım desenlerinden biridir. Nesne oluşturmayı sağlayan tek bir sınıf içerir ve bu sınıf sadece tek bir nesnenin yaratılmasını sağlar ve diğer sınıfların(yeni nesne üretmeleri yerine) bu nesneye erişebilmelerine olanak sağlar. Dosya işlemleri, veri tabanı bağlantıları, loglama işlemleri gibi karmaşık sistemlere erişimi kontrol eden sınıflarda Singleton örneği görmek mümkündür. Bu tarz sınıflardan yalnızca bir instance bulunması sistem için yeterli olacaktır. Peki bir sınıfın yalnızca bir nesnesi olmasını nasıl sağlayabiliriz ? Nesne üretimlerini Constructor metotlar sayesinde gerçekleştirdiğimizi düşünürsek, onu private olarak oluşturmak, dışarıdan nesne oluşturmanın önüne geçecektir. Constructor, private tanımlandığına göre nesne sınıf içerisinde oluşturulmalıdır."),
      Icerik(kategori_id:1,baslik: "Factory Pattern", icerik: "En önemli design patternlardan bir tanesidir. Birbirleri ile benzer yapıda olan nesnelerin nerede en verimli şekilde yaratılacağı probleminden dolayı ortaya çıkmıştır. Factory Pattern, aynı abstract class veya interface’den türeyen nesnelerin üretiminin bir class üzerinden sağlanmasıdır. Üretilecek olan nesnenin hangi class’tan olacağına subclass’lar karar verir. Factory Design Pattern, nesne yaratma işlemi için bir interface tasarlanmasını gerektirir ve subclass’ların nesne üretmesine olanak sağlar. Ayrıca, hangi sınıf nesnesinin oluşacağını da subclass’lar kendileri belirler."),
      Icerik(kategori_id:1,baslik: "Abstract Factory Pattern", icerik: "İlişkili nesnelerin bir arada yaratılmasını sağlar.Soyut bir arayüz veya sınıf sağlayan ve bu arayüzü veya sınıfı uygulayan alt sınıflar aracılığıyla farklı nesne varyasyonlarının oluşturulmasını destekleyen bir tasarım desenidir. Bu desen, bir grup birbirleriyle ilişkili veya bağımlı nesnenin yaratılmasını sağlar ve bu nesnelerin nasıl oluşturulacakları ile ilgili ayrıntıları istemci kodundan gizler. İstemci kod, soyut fabrika arayüzü üzerinden nesneleri oluşturur ve bu nesnelerin gerçek sınıflarını bilmeden kullanabilir. Abstract Factory pattern, kodun daha esnek, bakımı daha kolay ve yeniden kullanılabilir olmasını sağlar. Örneğin, bir araba fabrikası soyut fabrika deseniyle araba, motor ve lastik gibi ilgili nesneleri bir arada yaratabilir."),
      Icerik(kategori_id:1,baslik: "Builder Pattern", icerik: "Basit nesneleri kullanarak karmaşık nesnelerin adım adım oluşturulduğu bir tasarım desenidir. Genellikle nesnelerin oluşturulması için kullanılan birçok parametre veya seçenek varsa veya nesne oluşturma süreci karmaşıksa kullanılır. Builder pattern, Nesne oluşturmayı çok adımlı ve modüler hale getirir, böylece farklı özellik setlerine sahip nesnelerin oluşturulmasını kolaylaştırır.Örneğin, grafik arayüz öğeleri, belge oluşturma işlemleri veya karmaşık veri yapıları oluşturulurken Builder pattern kullanılabilir."),
      Icerik(kategori_id:1,baslik: "Prototype Pattern", icerik: "Prototype pattern, bir nesnenin klonlanması için kullanılan bir tasarım desenidir. Aynı sınıftan üretilecek olan ve pek çok ortak özelliği bulunan benzer nesnelerin üretimi sırasında gerçekleşebilecek karışıklıkları engellemek ve üretim maliyetini azaltmak amacı ile kullanılır. Özellikle oyun yazılımlarında kullanımını görmek mümkündür. Örneğin, bir savaş oyununda aynı askerden yüzlerce tane bulunurken bu askerlerin yalnızca kimlik numaraları farklıdır. Her defasında sıfırdan asker nesnesi yaratmak, constructor’u baştan sonra tekrar tekrar gerekli bilgilerle doldurmak yerine var olan asker nesneleri kopyalanır ve set metodu ile yalnızca kimlik numaraları vs. gibi değişecek bilgiler değiştirilir."),
      Icerik(kategori_id: 2, baslik: "Adapter Pattern", icerik: "Adapter tasarım deseni, bir sınıfın arabirimini, başka bir sınıfın beklediği arabirime dönüştürmek için kullanılan bir yapısal desendir. Bu desen, uyumsuz arabirimlere sahip olan sınıflar arasında uyum sağlamak için kullanılır.Mevcut kodu yeniden kullanabilir hale getirir ve sınıflar arasındaki sıkı bağlantıları azaltarak sistemdeki esnekliği artırır.Adapter deseni, özellikle farklı kütüphaneler arasında uyum sağlamak veya eski kodu yeni sistemlere entegre etmek gerektiğinde kullanışlıdır. Örneğin, bir uygulama eski bir veri tabanı API'sini kullanıyorsa ve yeni bir veri tabanı API'sine geçiş yapmak istiyorsa, Adapter deseni eski API'yi yeni API'ye uyumlu hale getirebilir."),
      Icerik(kategori_id: 2, baslik: "Composite Pattern", icerik: "Kendi içlerinde birbirlerinden farklı olan bir grup nesnenin sanki tek bir bütün nesneymiş gibi kullanılabilmesine imkan sağlayan tasarım kalıbıdır.Composite Pattern, nesneleri bir ağaç yapısında birleştirip uygulamanın genelindeki parça bütün ilişkisini yeniden düzenleyip şekillendirmektir.Yazılımcı, kullanıcının isteği doğrultusunda aynı türden veya farklı türlerden bir nesne topluluğu kullanmak zorunda ise, karmaşadan ve karışıklıktan kurtulmak için, tüm parçalar ile tek tek uğraşmaktansa composite pattern kullanabilir."),
     Icerik(kategori_id: 2, baslik: "Proxy Pattern", icerik: "Proxy Design Pattern, bir nesneye olan erişimin kontrol altına alınması amacı ile kullanılır. İstemcilerin direkt olarak ilgili nesneye ulaşması yerine bir vekil aracılığı ile (dolaylı olarak) nesneye ulaşmasını sağlar. Vekil nesne, yalnızca gerekli durumlarda asıl nesne ile iletişime geçer ve ilgili işlemler gerçekleştirilir.Geliştirdiğiniz bir uygulamada, bellek üzerinde büyük kaynak harcayan bir nesneye ihtiyaç duyduğunuzu varsayalım. Örneğin bu nesne bir resim üzerine işlem yapıyor olabilir. Haliyle böyle maliyetli bir nesneyi her zaman bellekte tutmak istemezsiniz. Sadece istemciden talep geldiği zaman nesneyi oluşturup, metodu çağırıp, işi bittiğinde de nesneyi bellekten kaldıran bir yapıya ihtiyacınız var. Diğer bir örnek ise bir nesne, çok önemli sorumlulukları gerçekleştiriyor olabilir. Bu nesneye diğer nesneler tarafından doğrudan erişilmesi güvenlik problemlerine sebebiyet verebilir.Güvenlik açısından sakıncalı durumlarda ise bu olumsuzluk, sistemin çökmesine kadar giden problemlere dahi sebep olabilir.İşte böyle durumlarda bir vekile ihtiyacınız var. Bu vekil yalnızca gerçekten ihtiyaç duyulduğu anda temsil ettiği neyseye erişim sağlayacak ve işlemleri gerçekleştirecektir."),
     Icerik(kategori_id: 2, baslik: "Fly Weight Pattern", icerik: "Flyweight tasarım deseni, benzer nesnelerin tekrar tekrar oluşturulması yerine ortak bellek alanlarını kullanarak bellek kullanımını azaltan bir yapısal tasarım desenidir. Özellikle, çok sayıda benzer nesnenin oluşturulması durumunda, bu desen bellek kullanımını optimize etmek için idealdir. Flyweight deseni, her bir nesnede tüm verileri tutmak yerine, ortak kısımları paylaşarak bellek kullanımını azaltır. Örneğin, bir uygulama içinde çok sayıda benzer metin dizisi bulunuyorsa, her metin dizisini ayrı ayrı saklamak yerine, ortak bir String Pool içinde saklamak daha verimli olabilir. Böylece, bellekte daha az yer kaplayarak daha fazla nesne depolanabilir. Flyweight tasarım deseni, özellikle bellek tüketimini azaltmak ve performansı artırmak istendiği durumlarda kullanılır. Bu desen, özellikle grafiksel kullanıcı arayüzleri gibi bellek yoğun uygulamalarda sıklıkla kullanılır."),
     Icerik(kategori_id: 2, baslik: "Facade Pattern", icerik: "Bir alt sistemin parçalarını oluşturan sınıfları istemciden soyutlayarak kullanımı daha da kolaylaştırmak için tasarlanmış bir tasarım kalıbıdır. Mimari açıdan, karmaşık ve detaylı bir sistemi organize eder ve bir bütün olarak istemcilere sunar.Alt sistem içindeki sınıfların birbirlerinden bağımsız olması ve Facade sınıfından bağımsız bir şekilde çalışabilmesi önemlidir. Facade, içerisindeki sınıfları içermeli ve operasyonları gerçekleştirirken bu sınıfların fonksiyonelliklerini kullanmalıdır. Bu sayede istemci, karmaşık alt sistem detaylarından soyutlanır ve yalnızca Facade arayüzü üzerinden işlemlerini gerçekleştirir. Bu durum, sistemin daha modüler, bakımı daha kolay ve daha kullanıcı dostu olmasını sağlar."),
      Icerik(kategori_id: 2, baslik: "Bridge Pattern", icerik: "Büyük sınıfları veya birbiriyle yakın ilişkili sınıfları, birbirinden bağımsız olarak geliştirilebilecek iki ayrı hiyerarşiye bölmeyi sağlayan bir tasarım desenidir.Örneğin,Döviz isimli bir arabirimimiz (interface) ve bu arabirimde implemente edilen USD ve EURO gibi sınıflarımız olsun. Bu durumda, bir Döviz nesnesini içeren bir soyut sınıf (abstract class) oluşturabilir ve bu soyut sınıfın alt sınıfları aracılığıyla Döviz sınıflarına erişim sağlayabiliriz. Bu şekilde, farklı döviz türlerine ilişkin işlemleri ve davranışları soyut sınıfın alt sınıflarında yönetebiliriz.Bridge deseni, köprü olarak adlandırılan bir araç kullanarak, soyutlamayı ve uygulamayı ayırarak, birbiriyle ilişkili ancak farklı geliştirme eksenlerine sahip sınıfları birbirinden bağımsız hale getirir. Bu, daha esnek, modüler ve bakımı kolay bir tasarımı sağlar."),
     Icerik(kategori_id: 2, baslik: "Decorator Pattern", icerik: "Decorator tasarım deseninin amacı, nesnelere dinamik olarak özellik eklemektir ve nesne kendisi de eklenen özelliklerden habersiz ve ayrı bir konumda olmalıdır. Yani, kodun belirli kısımlarında nesnelere belirli özellikler kazandırmak isteniyorsa ve bunu nesnenin kendi sınıfından ayrıştırılmış bir şekilde yapmak isteniyorsa, decorator tasarım desenini kullanmak uygun olacaktır.Örneğin, elimizde bir Phone arayüzü (interface) ve buna bağlı bir iPhone sınıfımız olduğunu varsayalım. Ancak daha sonra iPhone modelleri artmaya başladı ve temel bazı özelliklerde bazı değişiklikler yapıldı. Bu durumda, her iPhone modeli için ayrı ayrı sınıflar oluşturup tüm özellikleri tekrar tekrar yazmak yerine, decorator tasarım desenini kullanarak temel iPhone sınıfına ek sınıflar ekleyebiliriz. Bu ek sınıflar, temel iPhone sınıfının özelliklerini genişletebilir veya değiştirebilir, ancak temel sınıf bu değişikliklerden habersizdir. Decorator deseni, bir nesneye dinamik olarak davranış eklemek için idealdir ve özellikle nesnenin değişiklik yapmadan veya alt sınıflarını genişletmeden farklı özellikler eklemesi gerektiğinde kullanışlıdır. Bu sayede kodun daha esnek, modüler ve bakımı daha kolay hale gelir."),
      Icerik(kategori_id: 3, baslik: "Template Pattern", icerik: "Template Method , üst sınıfta bir algoritmanın iskeletini oluşturur ve alt sınıfların bu algoritmanın belirli adımlarını değiştirmeden yapısını değiştirmesine olanak tanır. Bu tasarım deseni, bir kalıp (template) olarak hizmet eden bir yöntem içerir ve alt sınıflar bu kalıbı uygulayarak kendi davranışlarını belirlerler.Template Method deseni, kodun tekrar kullanımını sağlar ve alt sınıflar arasında kodun ortak parçalarını paylaşır. Ayrıca, bir algoritmanın genel yapısını tanımlayarak, alt sınıfların sadece özelleştirilmiş davranışlarını belirtmelerine olanak tanır. "),
     Icerik(kategori_id: 3, baslik: "Mediator Pattern", icerik: " Nesneler arasındaki karmaşık ve kaotik bağımlılıkları azaltmayı sağlayan davranışsal bir tasarım desenidir. Bu desen, nesneler arasındaki doğrudan iletişimi sınırlar ve sadece bir mediator nesnesi üzerinden haberleşmelerini zorlar. Mediator tasarım deseni, birbiriyle bağımsız hale getirilmek istenen bileşenler arasındaki doğrudan iletişimi kesmenin gerekliliğini önerir. Bu bileşenler, doğrudan birbirleriyle iletişim kurmak yerine, özel bir mediator nesnesi aracılığıyla dolaylı olarak iş birliği yaparlar. Mediator nesnesi, bileşenler arasındaki iletişimi yönetir ve uygun mesajları ileterek işbirliğini sağlar. Bu sayede, bileşenler düzinelerce başka bileşene bağımlı olmak yerine, sadece tek bir mediator nesnesine bağımlı olurlar. Mediator deseni, karmaşık sistemlerdeki etkileşimi düzenlemek ve yönetmek için idealdir. Özellikle, çok sayıda nesne arasında karmaşık ilişkilerin bulunduğu durumlarda kullanılır. "),
     Icerik(kategori_id: 3, baslik: "Chain Of Responsibility", icerik: "Bir isteği işleyen nesnelerin zincirini oluşturarak, isteği işleyebilecek olan nesneyi bulana kadar her nesneye sırayla geçer. Bu desen, istekleri işleyecek olan nesnenin dinamik olarak belirlenmesine olanak sağlar.Bu desenin güzel yanı, işleyicilerin isteği zincirin bir sonraki adımına göndermek yerine isteği durdurmayı tercih edebilmesidir. Böylece, isteğin ilk aşamada durması gerekiyorsa, sonraki adımlara hiç iletmez. Örneğin, kullanıcı girişi hatalıysa, istek parametrelerini filtrelemeniz, sonuçları ön bellekte aramanız veya veri tabanından sorgulamamanız gerekmez.Bir banka örneğiyle açıklamak gerekirse, müşterilerden gelen tüm para çekme talepleri vezneye ulaşır. Eğer vezne talep edilen miktarı verme yetkisine sahipse, müşterinin ödemesi gerçekleştirilir; aksi takdirde istek müdüre iletilir. Müdür, kendi yetki durumuna göre parayı öder veya isteği genel müdüre iletir. Bu şekilde, her bir adım talebi işler ve gerekli kararları alır; istek zincirin sonuna ulaşana kadar süreç devam eder."),
     Icerik(kategori_id: 3, baslik: "Observer Pattern", icerik: "Adından da anlaşılacağı gibi, gözlemci, izleyici veya gözetmen gibi bir rolü ifade eden ve işlevini bu doğrultuda yerine getiren bir tasarım desenidir. Bu desen, elimizdeki mevcut bir nesnenin durumunda herhangi bir değişiklik olduğunda, bu değişikliklerden diğer nesneleri haberdar eden bir yapıyı ifade eder.Bu desenin temelinde, bir nesnenin durumu değiştiğinde ona bağımlı olan diğer nesnelerin bu değişiklikten etkilenmesi ve uygun şekilde tepki vermesi yatar. Observer deseni, birçok modern programlama dilinde ve çeşitli yazılım alanlarında kullanılan temel bir yapıdır. Özellikle GUI programlamada ve olay-tabanlı sistemlerde sıklıkla karşılaşılır."),
     Icerik(kategori_id: 3, baslik: "Strategy Pattern", icerik: "Strategy deseni, spesifik bir işi birçok farklı şekilde yapan bir sınıfı alarak bütün bu algoritmaları ayrı ayrı strategy  adı verilen ayrı sınıflara ayırmanızı önerir. Bu sayede, bu algoritmaları değiştirmeniz veya yeni algoritmalar eklemeniz gerektiğinde, bağlam sınıfınızı değiştirmeden kolaylıkla uygulama esnekliği sağlanır.Bu modelde,bağlam olarak adlandırılan orijinal sınıfta, oluşturduğumuz bu stratejilere referansları içeren alanlar oluşturulması gerekir. Bağlam sınıfı, algoritma seçimini veya davranışını yürütürken bu stratejileri kullanır.Örneğin, üç farklı şifreleme algoritması varsa, bunları şifreleme adını verdiğimiz bir arayüze implemente edilen üç farklı sınıf olarak oluşturabiliriz. Sonra, ihtiyaç duyduğumuz yerde bu sınıfları bağlam sınıfımızda kullanabiliriz. Bağlam sınıfı, çalışma zamanında hangi stratejiyi kullanacağını dinamik olarak belirleyebilir veya başlangıçta bir strateji belirleyebilir."),
     Icerik(kategori_id: 3, baslik: "Command Pattern", icerik: "Bir isteği bir nesne olarak temsil etmek ve bu isteği çağıran nesne ve isteği gerçekleştiren nesne arasındaki bağı gevşekleştirmek için kullanılan bir tasarım desenidir.Bu desenin ana fikri, bir isteği sarmalayan ve bir komut nesnesi olarak adlandırılan bir arayüze sahip olmaktır. Komut nesnesi, isteği çağıran nesneyle ilişkilendirilir ve isteği gerçekleştirmek için gereken tüm bilgileri içerir. Bu şekilde, isteği çağıran nesne, komut nesnesine bağımlıdır ancak gerçekleştirilen işlemlerden habersizdir.Özellikle geri alma (undo) işlemleri, iş akışları ve kullanıcı arabirimleri gibi senaryolarda sıklıkla kullanılır."),
     Icerik(kategori_id: 3, baslik: "State Pattern", icerik: "Bir nesnenin iç durumu değiştiğinde davranışını değiştirmesine izin veren davranışsal bir tasarım modelidir. Bu desen, nesnenin durumunu bir dizi özel durum nesnesi aracılığıyla temsil eder ve duruma bağlı olarak farklı davranışları gerçekleştirir.State deseni, Finite State Machine (Sonlu Durum Makinesi) kavramı ile yakından ilişkilidir. Herhangi bir uygulamada, bir nesnenin farklı durumlar arasında geçiş yapabileceği ve her durumun farklı davranışları tetikleyebileceği senaryolarda State Pattern kullanılabilir.State Pattern'in kullanımı, karmaşık if-else ifadeleri yerine nesneler arasındaki ilişkileri temsil eden daha modüler bir yapı sağlar. Her bir durum için ayrı bir somut sınıf oluşturulur ve bu durumlar, durum değişikliklerine göre nesnenin davranışını değiştirebilir.Örneğin, uzaktan kumandadaki düğmelere basarak bir televizyonun durumunu değiştirebilirsiniz. Televizyonun mevcut durumuna bağlı olarak, AÇIK durumdaysa kapatılabilir, sessize alınabilir veya özellikleri değiştirilebilir. Ancak TV KAPALI durumdaysa, düğmelere basıldığında bir işlem gerçekleşmeyecektir. KAPALI durumu için yalnızca bir sonraki olası durumun AÇIK konumuna gelmesi beklenir.Bu desen ayrıca fast food otomatları veya para ile alışveriş yapılan diğer makineler gibi sistemlerde de sıklıkla kullanılır. Herhangi bir makinenin farklı durumları ve bu durumlara bağlı olarak farklı işlemler gerçekleştirme ihtiyacı olduğunda, State Pattern kullanılabilir."),
     Icerik(kategori_id: 3, baslik: "Visitor Pattern", icerik: "Popüler bir tasarım kalıbı değildir ancak yazdığımız sınıflara sonradan modüler olarak metodlar eklememizi sağlar. Sınıfın olmayan özelliğini sonradan eklemeyi kolaylaştırır,işlemi ziyaretçi nesneleri yapar. Eğer sisteme yeni nesneler eklenmiyor, fakat sık sık yeni işlemlerin eklenmesi gerekiyorsa bu tasarım deseni kullanılabilir. Bu tasarım deseninin kullanılmasıyla, yapılacak işlemle ilgili kodların merkezi bir nesnede toplanır."),
     Icerik(kategori_id: 3, baslik: "Iterator Pattern", icerik: "Bir koleksiyonun elemanlarına erişmek ve bu elemanlar üzerinde dolaşmak için bir arayüz sağlayan bir tasarım desenidir. Bu desen, koleksiyonların iç yapısını gizler ve koleksiyondaki elemanlara erişimi standartlaştırır, böylece koleksiyonun yapısını değiştirmezseniz döngü işlemlerini değiştirmek gerekmez.Iterator Pattern'in temelinde, koleksiyonun elemanlarına erişmek için bir yineleyici(iterator) arayüzü bulunur. Bu arayüz, koleksiyonun her elemanına sırayla erişim sağlar ve bu elemanlar üzerinde işlem yapma olanağı sağlar. Yineleyici, koleksiyonun iç yapısını gizler ve döngü işlemlerini kolaylaştırır. Iterator Pattern'i kullanan bir uygulama, koleksiyonun iç yapısını bilmeden elemanlarına erişebilir ve bu elemanlar üzerinde döngüler veya işlemler gerçekleştirebilir. Bu desen, yazılımın modülerliğini ve esnekliğini artırır ve kodun daha okunabilir olmasını sağlar. Bu desen genellikle programlama dillerindeki standart kütüphanelerde, özellikle de koleksiyon veri yapılarında kullanılır. Iterator Pattern, bir dizi veya listedeki elemanlar üzerinde dolaşmak gibi yaygın işlemleri daha basit hale getirir ve tekrar kullanılabilirlik sağlar."),
     Icerik(kategori_id: 3, baslik: "Interpreter Pattern", icerik: "Interpreter Pattern bir dilin veya dil benzeri bir yapıdaki ifadelerin yorumlanmasını ve işlenmesini sağlayan bir tasarım desenidir. Bu desen, belirli bir dilde veya dil benzeri bir yapıda yazılmış ifadeleri değerlendirmek, yorumlamak ve işlemek için bir arayüz sağlar.Interpreter Pattern'in temelinde, bir dilin sözdizimi veya yapısal bileşenlerini yorumlamak için bir yorumlayıcı(interpreter) bulunur. Bu yorumlayıcı, belirli bir dilde yazılmış ifadeleri yorumlar ve bu ifadelerin anlamını çıkarır. Örneğin, bir matematiksel ifadeyi yorumlayarak sonucunu hesaplar veya bir programlama dili ifadesini çalıştırır.Bu desen genellikle bir dizi nesne arasında işlem yapmak veya belirli bir dilde yazılmış ifadeleri yorumlamak gibi senaryolarda kullanılır. Özellikle, derleyiciler, yorumlayıcılar, veritabanı sorguları ve doğal dil işleme gibi alanlarda Interpreter Pattern sıkça kullanılır."),
     Icerik(kategori_id: 3, baslik: "Memento Pattern", icerik: "Memento deseni, bir nesnenin iç durumunu kaydetmek ve gerektiğinde önceki bir duruma geri yüklemek için kullanılan bir tasarım desenidir.Bu desenin ana amacı, bir nesnenin iç durumunu bir memento adı verilen bir nesne aracılığıyla kaydetmektir. Memento, bu durumu kapsüller ve gerektiğinde geri yüklemek için gerekli olan bilgileri içerir. Bu sayede, nesnenin geçmiş durumlarına geri dönmek veya bir geri alma (undo) işlemi gerçekleştirmek mümkün olur. Memento deseni, özellikle bir nesnenin geçmiş durumlarını izlemek, geri alma işlemleri gerçekleştirmek veya durum geçmişini saklamak gerektiğinde kullanılır."),


    ];

}